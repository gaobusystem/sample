サブクエリ　from国 selectを直接指定

union　重複削除

union all 重複あり

データへのアクセスパスに影響がないか

データをとってきてからの話

ワーキングメモリの容量

SQLのパースと実行計画の生成・評価にオーバーへっとがかかる

ぐるぐる系　ストアド？　遅い　並列で処理できない　トランザクション処理に有利

ガツン系　並列可

temp落ち

仮想テーブル再帰的な共通テーブル式
自分自身を参照することで、前に行った処理の結果を利用して同じ処理を繰り返すことができる。


WITH RECURSIVE
  仮想テーブル名 AS 
  -- 仮想テーブルの生成クエリ
  (
    非再帰項（仮想テーブルの先頭行になるレコード）
    UNION ALL
    再帰項（自身を参照・条件設定して抽出されたレコード）
  )
WITH RECURSIVE
  Oda AS (
    -- 非再帰項
    SELECT id, last_name, first_name, parent_id
    FROM Family 
    WHERE last_name = "織田" AND parent_id IS NULL
    UNION ALL
    -- 再帰項
    SELECT child.id, child.last_name, child.first_name, child.parent_id
    FROM Oda -- 自身を参照
    JOIN Family as child -- 元テーブルからデータを追加 <1>
    ON Oda.id = child.parent_id
  )
SELECT * FROM Oda;

オプティマイザのアルゴリズム
①Nested Loops
　　駆動表が小さいほど、性能は良い（内部表の結合キーにインデックス（一意が良い）が存在する）
②Hash
③Sort Merge

Hash
	ハッシュ結合はまず小さいテーブルをスキャンして、結合キーに対してハッシュ関数を適用することでハッシュ値に変換
	もう一方の大きなテーブルをスキャンして、結合キーがそのハッシュ値に存在するかで結合する
	メモリにハッシュが作られるのでメモリを消費
	ハッシュの並びはバラバラなので等値結合、フルスキャンになる
	有効なケース
		・Nested Loopsの内部表にindexがない
		・Nested Loopsの内部表のヒット件数が多い
		・Nested Loopsで適切な駆動表が存在しない
	OLTP処理（オンライン）では使わない
	同時並走する処理が少ない夜間バッチ、スループットの低いシステムに使う

Sort Merge
	双方のテーブルをソートしてから、結合
	ソートするのでメモリ消費する。indexがあればソート不要
	indexがあれば採用

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
シーケンスオブジェクト
identity列

どちらも極力使わない。使うなら、シーケンスオブジェクト

■シーケンスオブジェクトの定義の例
CREATE SEQUENCE testseq
START WITH 1
INCREMENT BY 1
MAXVALUE 100000
MINVALUE 1
CYCLE;

insert into hogetbl values(NEXT VALUE FOR nextval, 'a','b', );

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
インデックス
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
B-tree　B+tree
ビットマップインデックス　更新があまりないケースで使用
ハッシュインデックス

B+tree

カーディナリティ
	値のばらつき具合を示す概念
	最も高いのはすべての行の値が異なる一意の列
	最も低いのは値が１種類

クラスタリングファクタが低い＝インデックススキャンに有利
　　データがまとまって存在

クラスタリングファクタが高い＝インデックススキャンに不利
		バラバラ

インデックス作成の基準
　カーディナリティが高い
　選択率（対象件数／全件）が低い。少ない行の絞りこみ　5～10％前後

	選択率がそれより高いと、フルスキャンの方が早い




